--- a/analysis/signals.py
+++ b/analysis/signals.py
@@
 async def generate_trading_signals(market_data: pd.DataFrame, symbol: str = None) -> Dict[str, Any]:
@@
-        # Определение режима рынка
+        # Определение режима рынка
         regime = determine_market_regime(prices, volumes)
         weights = get_regime_weights(regime, symbol)
 
-        # Расчет индикаторов
-        ti = TechnicalIndicators(market_data)
+        # Профиль актива для адаптивного множителя Supertrend
+        asset_profile = calculate_asset_profile(
+            symbol=symbol, highs=highs, lows=lows, prices=prices, volumes=volumes
+        )
+        multiplier = adaptive_supertrend_multiplier(asset_profile)
+
+        # Расчет индикаторов
+        ti = TechnicalIndicators(market_data)
 
         # Параллельный расчет индикаторов (убрал ADX - не используется)
-        indicators_tasks = [
+        indicators_tasks = [
             asyncio.to_thread(ti.ema, 9),
             asyncio.to_thread(ti.ema, 21),
             asyncio.to_thread(ti.macd),
             asyncio.to_thread(ti.rsi),
             asyncio.to_thread(ti.bollinger_bands),
+            asyncio.to_thread(ti.supertrend, 10, multiplier),
         ]
 
-        ema9, ema21, macd_data, rsi, bb_data = await asyncio.gather(*indicators_tasks)
+        ema9, ema21, macd_data, rsi, bb_data, supertrend_data = await asyncio.gather(*indicators_tasks)
@@
-        # Расчет профиля актива (исправленный вызов)
-        asset_profile = calculate_asset_profile(
-            symbol=symbol,
-            highs=highs,
-            lows=lows,
-            prices=prices,
-            volumes=volumes
-        )
+        # asset_profile уже посчитан выше
 
         # Сбор всех сигналов
         all_signals = []
@@
-        # MACD сигналы
-        if macd_data is not None and 'macd' in macd_data and 'signal' in macd_data:
-            macd_signal = analyze_macd_signals(macd_data['macd'], macd_data['signal'], prices)
+        # MACD сигналы (поддержка dict и tuple), подтверждение 1 бар чтобы ловить кросс на хвосте
+        if macd_data is not None:
+            if isinstance(macd_data, dict) and 'macd' in macd_data and 'signal' in macd_data:
+                _macd_line, _sig_line = macd_data['macd'], macd_data['signal']
+            elif isinstance(macd_data, (tuple, list)) and len(macd_data) >= 2:
+                _macd_line, _sig_line = macd_data[0], macd_data[1]
+            else:
+                _macd_line = _sig_line = None
+            macd_signal = analyze_macd_signals(_macd_line, _sig_line, prices, confirmation_bars=1) if (_macd_line is not None and _sig_line is not None) else None
             if macd_signal:
                 macd_signal['weight'] = weights.macd_weight
                 all_signals.append(macd_signal)
@@
-        # Bollinger Bands сигналы
-        if bb_data is not None and 'upper' in bb_data and 'lower' in bb_data and 'middle' in bb_data:
-            bb_signals = analyze_bollinger_bands_signals(
-                prices, bb_data['upper'], bb_data['lower'], bb_data['middle']
-            )
+        # Bollinger Bands сигналы (поддержка dict и tuple)
+        if bb_data is not None:
+            if isinstance(bb_data, dict) and all(k in bb_data for k in ('upper','middle','lower')):
+                bb_upper, bb_middle, bb_lower = bb_data['upper'], bb_data['middle'], bb_data['lower']
+            elif isinstance(bb_data, (tuple, list)) and len(bb_data) >= 3:
+                bb_upper, bb_middle, bb_lower = bb_data[0], bb_data[1], bb_data[2]
+            else:
+                bb_upper = bb_middle = bb_lower = None
+            if bb_upper is not None and bb_lower is not None and bb_middle is not None:
+                bb_signals = analyze_bollinger_bands_signals(prices, bb_upper, bb_lower, bb_middle)
             for signal in bb_signals:
                 # Исправление: правильное имя веса для Bollinger Bands
                 signal['weight'] = weights.bollinger_weight
                 all_signals.append(signal)
@@
         # Trend сигналы
         trend_signal = analyze_trend_signals(prices)
         if trend_signal:
             trend_signal['weight'] = weights.trend_weight
             all_signals.append(trend_signal)
+
+        # Supertrend сигналы (поддержка dict/tuple)
+        if supertrend_data is not None:
+            if isinstance(supertrend_data, dict) and all(k in supertrend_data for k in ('supertrend','direction')):
+                st_line, st_dir = supertrend_data['supertrend'], supertrend_data['direction']
+            elif isinstance(supertrend_data, (tuple, list)) and len(supertrend_data) >= 2:
+                st_line, st_dir = supertrend_data[0], supertrend_data[1]
+            else:
+                st_line = st_dir = None
+            if st_line is not None and st_dir is not None and len(st_dir) > 1:
+                prev_dir, curr_dir = st_dir[-2], st_dir[-1]
+                if prev_dir == -1 and curr_dir == 1:
+                    all_signals.append({
+                        "type": SignalType.BUY.value,
+                        "confidence": SignalConfidence.HIGH.value,
+                        "indicator": "Supertrend",
+                        "message": f"Разворот Supertrend вверх (множитель {multiplier:.2f})",
+                        "strength": 80,
+                        "weight": weights.supertrend_weight,
+                        "details": {"supertrend_value": float(st_line[-1])}
+                    })
+                elif prev_dir == 1 and curr_dir == -1:
+                    all_signals.append({
+                        "type": SignalType.SELL.value,
+                        "confidence": SignalConfidence.HIGH.value,
+                        "indicator": "Supertrend",
+                        "message": f"Разворот Supertrend вниз (множитель {multiplier:.2f})",
+                        "strength": 80,
+                        "weight": weights.supertrend_weight,
+                        "details": {"supertrend_value": float(st_line[-1])}
+                    })