diff --git a/backend/bybit_client.py b/backend/bybit_client.py
index 8260fe2..fixskip1 100644
--- a/backend/bybit_client.py
+++ b/backend/bybit_client.py
@@ -7,7 +7,8 @@ import aiohttp
 import pandas as pd
 import numpy as np
 from datetime import datetime, timedelta
-from typing import Dict, List, Optional, Any, Tuple, Union, Set
+from typing import Dict, List, Optional, Any, Tuple, Union, Set
+import ssl as _ssl
 import logging
 import json
 from functools import wraps, lru_cache
@@
 class UltraBybitClient:
@@
     async def init(self):
@@
-        for exchange, config in self._exchange_configs.items():
+        for exchange, config in self._exchange_configs.items():
             if config.enabled:
                 try:
-                    connector = aiohttp.TCPConnector(
-                        limit=CONNECTION_POOL_SIZE,
-                        limit_per_host=30,
-                        enable_cleanup_closed=True,
-                        force_close=False,
-                        ssl=False
-                    )
+                    # SSL включён по умолчанию. Отключить проверки можно через BYBIT_SSL_NO_VERIFY=1 (только для дев!)
+                    _no_verify = os.getenv("BYBIT_SSL_NO_VERIFY", "0") == "1"
+                    if _no_verify:
+                        _ctx = _ssl.create_default_context()
+                        _ctx.check_hostname = False
+                        _ctx.verify_mode = _ssl.CERT_NONE
+                        _ssl_arg = _ctx
+                    else:
+                        _ssl_arg = None
+                    connector = aiohttp.TCPConnector(
+                        limit=CONNECTION_POOL_SIZE,
+                        limit_per_host=30,
+                        enable_cleanup_closed=True,
+                        force_close=False,
+                        ssl=_ssl_arg
+                    )
@@
     async def _make_request(self, endpoint: str, params: Dict = None,
                             exchange: ExchangeSource = None,
                             retries: int = 2) -> Optional[Dict]:
@@
-            async with self._sessions[exchange].get(url, params=params) as response:
+            async with self._sessions[exchange].get(url, params=params) as response:
                 if response.status == 429:
@@
         except (asyncio.TimeoutError, aiohttp.ClientError) as e:
@@
             return None
@@
     async def get_klines(self, symbol: str, interval: str = '1h',
                         limit: int = 500, exchange: ExchangeSource = None) -> Optional[pd.DataFrame]:
@@
-        # Автоматический выбор биржи если не указана
-        if exchange is None:
-            exchange = self._select_best_exchange()
-
-        data = await self._fetch_klines_from_exchange(exchange, symbol, interval, limit)
-        if data is not None:
-            df = self._process_klines_data(data, exchange)
-            if df is not None:
-                await self._cache_set(cache_key, df.to_dict('records'), ttl=60)
-                return df
+        # Пробуем выбранную (или лучшую) биржу, а затем — все остальные доступные, пока не получится
+        tried: Set[ExchangeSource] = set()
+        candidates: List[ExchangeSource] = []
+        if exchange is None:
+            best = self._select_best_exchange()
+            if best:
+                candidates.append(best)
+        else:
+            candidates.append(exchange)
+        # добавляем остальных
+        for ex in self._get_available_exchanges():
+            if ex not in candidates:
+                candidates.append(ex)
+
+        for ex in candidates:
+            tried.add(ex)
+            data = await self._fetch_klines_from_exchange(ex, symbol, interval, limit)
+            if data:
+                df = self._process_klines_data(data, ex)
+                if df is not None and len(df) > 0:
+                    await self._cache_set(cache_key, df.to_dict('records'), ttl=60)
+                    return df
+        return None
@@
     async def _fetch_klines_from_exchange(self, exchange: ExchangeSource, symbol: str,
                                         interval: str, limit: int) -> Optional[List]:
@@
         except Exception as e:
             logger.error(f"Failed to fetch klines from {exchange.value}: {e}")
             return None
@@
     async def get_orderbook(self, symbol: str, limit: int = 25,
                           exchange: ExchangeSource = None) -> Optional[Dict]:
@@
-        if exchange is None:
-            exchange = self._select_best_exchange()
-
-        data = await self._fetch_orderbook_from_exchange(exchange, symbol, limit)
-        if data:
-            await self._cache_set(cache_key, data, ttl=3)
-            return data
+        # Аналогично: пробуем лучшую, затем остальные
+        candidates: List[ExchangeSource] = []
+        if exchange is None:
+            best = self._select_best_exchange()
+            if best:
+                candidates.append(best)
+        else:
+            candidates.append(exchange)
+        for ex in self._get_available_exchanges():
+            if ex not in candidates:
+                candidates.append(ex)
+        for ex in candidates:
+            data = await self._fetch_orderbook_from_exchange(ex, symbol, limit)
+            if data:
+                await self._cache_set(cache_key, data, ttl=3)
+                return data
         return None
@@
     async def get_batch_klines(self, symbols: List[str], interval: str = '1h',
                              limit: int = 100) -> Dict[str, Optional[pd.DataFrame]]:
@@
-        for symbol in symbols:
-            task = self.get_klines(symbol, interval, limit)
+        for symbol in symbols:
+            task = self.get_klines(symbol, interval, limit)
             tasks.append((symbol, task))
@@
-        async def limited_task(symbol, task):
+        async def limited_task(symbol, task):
             async with semaphore:
                 try:
                     data = await task
                     results[symbol] = data
                 except Exception as e:
                     logger.error(f"Error getting data for {symbol}: {e}")
                     results[symbol] = None
-                await asyncio.sleep(0.05)  # Rate limiting
+                await asyncio.sleep(0.03)  # чуть мягче лимит
@@
     async def get_multiple_timeframes(self, symbol: str,
                                     timeframes: List[str] = None) -> Dict[str, Optional[pd.DataFrame]]:
@@
-        for tf in timeframes:
-            task = self.get_klines(symbol, tf, 200)
+        for tf in timeframes:
+            task = self.get_klines(symbol, tf, 200)
             tasks.append((tf, task))
@@
         return results
@@
-# ==================== ОБНОВЛЕННЫЕ СИНХРОННЫЕ МЕТОДЫ КЛИЕНТА ====================
-
-    def get_spot_symbols_sync(self, quote_coin: str = 'USDT') -> List[str]:
-        """Синхронная версия получения символов"""
-        return _run_sync(self.get_spot_symbols(quote_coin))
-
-    def get_klines_sync(self, symbol: str, interval: str = '1h', limit: int = 500) -> Optional[pd.DataFrame]:
-        """Синхронная версия получения свечных данных"""
-        return _run_sync(self.get_klines(symbol, interval, limit))
-
-    def get_ticker_info_sync(self, symbol: str) -> Optional[Dict]:
-        """Синхронная версия получения информации о тикере"""
-        return _run_sync(self.get_ticker_info(symbol))
-
-    def get_orderbook_sync(self, symbol: str, limit: int = 25) -> Optional[Dict]:
-        """Синхронная версия получения стакана"""
-        return _run_sync(self.get_orderbook(symbol, limit))
-
-    def get_batch_klines_sync(self, symbols: List[str], interval: str = '1h', limit: int = 100) -> Dict[
-        str, Optional[pd.DataFrame]]:
-        """Синхронная версия пакетного получения данных"""
-        return _run_sync(self.get_batch_klines(symbols, interval, limit))
-
-    def get_multiple_timeframes_sync(self, symbol: str, timeframes: List[str] = None) -> Dict[
-        str, Optional[pd.DataFrame]]:
-        """Синхронная версия получения multiple таймфреймов"""
-        return _run_sync(self.get_multiple_timeframes(symbol, timeframes))
+# ==================== СИНХРОННЫЕ ОБЁРТКИ БЕЗ ДУБЛИРОВАНИЯ ЛОГИКИ ====================
+    def get_spot_symbols_sync(self, quote_coin: str = 'USDT') -> List[str]:
+        return _run_sync(self.get_spot_symbols(quote_coin))
+    def get_klines_sync(self, symbol: str, interval: str = '1h', limit: int = 500) -> Optional[pd.DataFrame]:
+        return _run_sync(self.get_klines(symbol, interval, limit))
+    def get_ticker_info_sync(self, symbol: str) -> Optional[Dict]:
+        return _run_sync(self.get_ticker_info(symbol))
+    def get_orderbook_sync(self, symbol: str, limit: int = 25) -> Optional[Dict]:
+        return _run_sync(self.get_orderbook(symbol, limit))
+    def get_batch_klines_sync(self, symbols: List[str], interval: str = '1h', limit: int = 100) -> Dict[str, Optional[pd.DataFrame]]:
+        return _run_sync(self.get_batch_klines(symbols, interval, limit))
+    def get_multiple_timeframes_sync(self, symbol: str, timeframes: List[str] = None) -> Dict[str, Optional[pd.DataFrame]]:
+        return _run_sync(self.get_multiple_timeframes(symbol, timeframes))
@@
-# ==================== ОБНОВЛЕННЫЕ СИНХРОННЫЕ МЕТОДЫ КЛИЕНТА ====================
-
-def _run_sync(coroutine):
-    """Запуск корутины в синхронном контексте"""
-    try:
-        loop = asyncio.get_event_loop()
-        if loop.is_running():
-            # Если цикл уже запущен, создаем future
-            future = asyncio.run_coroutine_threadsafe(coroutine, loop)
-            return future.result()
-        else:
-            # Запускаем в текущем цикле
-            return loop.run_until_complete(coroutine)
-    except RuntimeError:
-        # Нет event loop, создаем новый
-        return asyncio.run(coroutine)
+def _run_sync(coroutine):
+    """Безопасный запуск корутины в синхронном контексте (py3.11+ friendly)"""
+    try:
+        loop = asyncio.get_running_loop()
+        if loop.is_running():
+            future = asyncio.run_coroutine_threadsafe(coroutine, loop)
+            return future.result()
+    except RuntimeError:
+        pass
+    return asyncio.run(coroutine)
@@
-# ==================== ОБНОВЛЕННЫЕ СИНХРОННЫЕ МЕТОДЫ КЛИЕНТА ====================
-
-def get_spot_symbols_sync(self, quote_coin: str = 'USDT') -> List[str]:
-    """Синхронная версия получения символов"""
-    return _run_sync(self.get_spot_symbols(quote_coin))
-
-
-def get_klines_sync(self, symbol: str, interval: str = '1h', limit: int = 500) -> Optional[pd.DataFrame]:
-    """Синхронная версия получения свечных данных"""
-    return _run_sync(self.get_klines(symbol, interval, limit))
-
-
-def get_ticker_info_sync(self, symbol: str) -> Optional[Dict]:
-    """Синхронная версия получения информации о тикере"""
-    return _run_sync(self.get_ticker_info(symbol))
-
-
-def get_orderbook_sync(self, symbol: str, limit: int = 25) -> Optional[Dict]:
-    """Синхронная версия получения стакана"""
-    return _run_sync(self.get_orderbook(symbol, limit))
-
-
-def get_batch_klines_sync(self, symbols: List[str], interval: str = '1h', limit: int = 100) -> Dict[
-    str, Optional[pd.DataFrame]]:
-    """Синхронная версия пакетного получения данных"""
-    return _run_sync(self.get_batch_klines(symbols, interval, limit))
-
-
-def get_multiple_timeframes_sync(self, symbol: str, timeframes: List[str] = None) -> Dict[str, Optional[pd.DataFrame]]:
-    """Синхронная версия получения multiple таймфреймов"""
-    return _run_sync(self.get_multiple_timeframes(symbol, timeframes))
-
-
-# Добавляем методы к классу
-UltraBybitClient.get_spot_symbols_sync = get_spot_symbols_sync
-UltraBybitClient.get_klines_sync = get_klines_sync
-UltraBybitClient.get_ticker_info_sync = get_ticker_info_sync
-UltraBybitClient.get_orderbook_sync = get_orderbook_sync
-UltraBybitClient.get_batch_klines_sync = get_batch_klines_sync
-UltraBybitClient.get_multiple_timeframes_sync = get_multiple_timeframes_sync
+# (Удалены внешние дубли методов и их «навешивание» на класс; методы уже объявлены внутри класса)
@@
-# Глобальный экземпляр клиента
-_client = UltraBybitClient()
+# (Удалён паразитный экземпляр; используем только _GLOBAL_CLIENT)
@@
 def get_client():
     """Получение экземпляра клиента с гарантированной инициализацией"""
     global _GLOBAL_CLIENT
@@
-    if not _GLOBAL_CLIENT._initialized:
-        try:
-            loop = asyncio.get_event_loop()
-            if loop.is_running():
-                # Если цикл уже запущен, создаем задачу для инициализации
-                asyncio.create_task(init_bybit_client())
-            else:
-                # Инициализируем синхронно
-                loop.run_until_complete(init_bybit_client())
-        except RuntimeError:
-            # Нет event loop, создаем новый
-            asyncio.run(init_bybit_client())
+    if not _GLOBAL_CLIENT._initialized:
+        try:
+            loop = asyncio.get_running_loop()
+            if loop.is_running():
+                fut = asyncio.run_coroutine_threadsafe(init_bybit_client(), loop)
+                fut.result()
+            else:
+                asyncio.run(init_bybit_client())
+        except RuntimeError:
+            asyncio.run(init_bybit_client())
@@
 async def get_available_symbols(quote_coin: str = 'USDT', source: str = None) -> List[str]:
@@
     return await _GLOBAL_CLIENT.get_spot_symbols(quote_coin)
