# tools/apply_unskip_fixes.py
import re
from pathlib import Path

TARGET = Path("backend/bybit_client.py")
BACKUP = TARGET.with_suffix(".py.bak")

def read():
    return TARGET.read_text(encoding="utf-8", errors="replace")

def write(txt):
    TARGET.write_text(txt, encoding="utf-8", newline="")

def backup(txt):
    BACKUP.write_text(txt, encoding="utf-8", newline="")

def patch_ssl_connector(txt):
    """
    Меняем ssl=False на управляемый через BYBIT_SSL_NO_VERIFY.
    Ищем создание aiohttp.TCPConnector(...) в init()/создателе сессий.
    """
    pat = re.compile(
        r"TCPConnector\(\s*limit\s*=\s*CONNECTION_POOL_SIZE,\s*limit_per_host\s*=\s*30,\s*enable_cleanup_closed\s*=\s*True,\s*force_close\s*=\s*False,\s*ssl\s*=\s*False\s*\)",
        re.S
    )
    if not pat.search(txt):
        return txt, False

    repl = (
        "TCPConnector(\n"
        "                        limit=CONNECTION_POOL_SIZE,\n"
        "                        limit_per_host=30,\n"
        "                        enable_cleanup_closed=True,\n"
        "                        force_close=False,\n"
        "                        ssl=_ssl_arg\n"
        "                    )"
    )

    # вставим подготовку _ssl_arg выше по функции (если ещё не вставлена)
    header_pat = re.compile(r"(for\s+exchange,\s*config\s+in\s+self\._exchange_configs\.items\(\):\s*[\r\n]+(?:\s*)if\s+config\.enabled:\s*)", re.S)
    if "_ssl_arg" not in txt:
        txt = header_pat.sub(
            r"""\1# SSL включён по умолчанию; отключить проверки (только для дев) можно BYBIT_SSL_NO_VERIFY=1
                _no_verify = os.getenv("BYBIT_SSL_NO_VERIFY", "0") == "1"
                if _no_verify:
                    import ssl as _ssl
                    _ctx = _ssl.create_default_context()
                    _ctx.check_hostname = False
                    _ctx.verify_mode = _ssl.CERT_NONE
                    _ssl_arg = _ctx
                else:
                    _ssl_arg = None
                """,
            txt
        )

    txt = pat.sub(repl, txt)
    return txt, True

def patch_symbols_kraken_huobi(txt):
    """
    Переписываем ветки KRAKEN/HUOBI в _fetch_symbols_from_exchange.
    Делаем это через замену elif-блоков.
    """
    # Kraken block
    kraken_pat = re.compile(
        r"""elif\s+exchange\s*==\s*ExchangeSource\.KRAKEN:\s*
            (?P<body>
                .*?
            )
            (?=elif\s+exchange\s*==\s*ExchangeSource\.HUOBI:|elif|else:|return|\Z)
        """,
        re.S | re.X
    )
    if kraken_pat.search(txt):
        kraken_repl = (
            "elif exchange == ExchangeSource.KRAKEN:\n"
            "                # _process_response уже мог вернуть 'result'; работаем с парами, нормализуем X/Z-префиксы\n"
            "                data = await self._make_request('0/public/AssetPairs', None, exchange)\n"
            "                pairs = data.get('pairs') if isinstance(data, dict) else None\n"
            "                out = []\n"
            "                qc = quote_coin.upper()\n"
            "                def _norm(s):\n"
            "                    return (s or '').replace('X','').replace('Z','').upper()\n"
            "                if isinstance(pairs, dict):\n"
            "                    for name, info in pairs.items():\n"
            "                        try:\n"
            "                            quote = _norm(info.get('quote'))\n"
            "                            if quote in (qc, f'Z{qc}', f'X{qc}') and not name.endswith('.d'):\n"
            "                                out.append(name)\n"
            "                        except Exception:\n"
            "                            continue\n"
            "                    return out\n"
            "                if isinstance(data, dict):\n"
            "                    for name, info in data.items():\n"
            "                        if not isinstance(info, dict):\n"
            "                            continue\n"
            "                        try:\n"
            "                            quote = _norm(info.get('quote'))\n"
            "                            if quote in (qc, f'Z{qc}', f'X{qc}') and not name.endswith('.d'):\n"
            "                                out.append(name)\n"
            "                        except Exception:\n"
            "                            continue\n"
            "                return out\n"
        )
        txt = kraken_pat.sub(kraken_repl, txt)

    # Huobi block
    huobi_pat = re.compile(
        r"""elif\s+exchange\s*==\s*ExchangeSource\.HUOBI:\s*
            (?P<body>
                .*?
            )
            (?=elif\s+exchange\s*==\s*ExchangeSource\.|else:|return|\Z)
        """,
        re.S | re.X
    )
    if huobi_pat.search(txt):
        huobi_repl = (
            "elif exchange == ExchangeSource.HUOBI:\n"
            "                # _process_response мог уже вернуть список; если пришёл dict — берём 'data'\n"
            "                rows = await self._make_request('v1/common/symbols', None, exchange)\n"
            "                rows = rows if isinstance(rows, list) else (rows.get('data') or [])\n"
            "                qc = quote_coin.upper()\n"
            "                out = []\n"
            "                for r in rows:\n"
            "                    try:\n"
            "                        q = (r.get('quote-currency') or r.get('quoteCurrency') or '').upper()\n"
            "                        if q == qc and r.get('state') in ('online','trading'):\n"
            "                            out.append((r.get('symbol') or '').upper())\n"
            "                    except Exception:\n"
            "                        continue\n"
            "                return out\n"
        )
        txt = huobi_pat.sub(huobi_repl, txt)
    return txt, True

def patch_run_sync(txt):
    pat = re.compile(
        r"def\s+_run_sync\([^)]*\):\s*[\r\n]+"
        r"(?P<body>[\s\S]{0,800}?)"
        r"(?=#[^\n]*|def\s|\Z)"
    )
    m = pat.search(txt)
    if not m:
        return txt, False
    repl = (
        "def _run_sync(coroutine):\n"
        "    \"\"\"Py3.11+-дружелюбный запуск корутины из sync-кода (PyCharm/Win10 safe).\"\"\"\n"
        "    try:\n"
        "        loop = asyncio.get_running_loop()\n"
        "        if loop.is_running():\n"
        "            fut = asyncio.run_coroutine_threadsafe(coroutine, loop)\n"
        "            return fut.result()\n"
        "    except RuntimeError:\n"
        "        pass\n"
        "    return asyncio.run(coroutine)\n"
    )
    start, end = m.span()
    txt = txt[:start] + repl + txt[end:]
    return txt, True

def remove_method_rebinding(txt):
    """
    Удаляем строки вида:
      UltraBybitClient.get_..._sync = get_..._sync
    чтобы не дублировать методы.
    """
    before = txt
    txt = re.sub(
        r"(?m)^\s*UltraBybitClient\.get_[a-zA-Z0-9_]+\s*=\s*get_[a-zA-Z0-9_]+\s*$\r?\n?",
        "", txt
    )
    return txt, (txt != before)

def main():
    if not TARGET.exists():
        print(f"[!] Не нашёл файл: {TARGET}")
        return
    original = read()
    backup(original)
    changed = False

    txt, ok1 = patch_ssl_connector(original)
    if ok1:
        print("[+] SSL-коннектор: включён безопасный режим (BYBIT_SSL_NO_VERIFY=1 для дева).")
        changed = True
    else:
        txt = original  # может уже применено

    txt, ok2 = patch_symbols_kraken_huobi(txt)
    if ok2:
        print("[+] Kraken/Huobi: логика получения символов обновлена.")
        changed = True

    txt, ok3 = patch_run_sync(txt)
    if ok3:
        print("[+] _run_sync: заменён на безопасный для PyCharm/Win10 вариант.")
        changed = True

    txt, ok4 = remove_method_rebinding(txt)
    if ok4:
        print("[+] Удалено дублирующее «навешивание» sync-методов на класс.")

    if changed or ok4:
        write(txt)
        print(f"[✓] Готово. Бэкап: {BACKUP}")
    else:
        print("[i] Изменений не внесено (похоже, фиксы уже применены). Бэкап всё равно создан.")

if __name__ == "__main__":
    main()
