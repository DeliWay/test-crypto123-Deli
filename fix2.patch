diff --git a/backend/bybit_client.py b/backend/bybit_client.py
index 1111111..3333333 100644
--- a/backend/bybit_client.py
+++ b/backend/bybit_client.py
@@ -1,12 +1,16 @@
 import os
 import asyncio
 import aiohttp
 import logging
 import time
+from typing import Any, Iterable

 logger = logging.getLogger(__name__)

 class BybitClientError(Exception):
     def __init__(self, code: str, details: str = ""):
         super().__init__(f"{code}: {details}")
         self.code = code
         self.details = details

 class UltraBybitClient:
@@ -18,42 +22,53 @@ class UltraBybitClient:
         self._session = session
         self._session_owner = session is None
         self.timeout = aiohttp.ClientTimeout(total=20)
         # in-process caches
         self.cache_ttl_seconds = int(os.getenv("BYBIT_CACHE_TTL", "300"))
-        self.symbols_cache = {}
-        self.generic_cache = {}
+        self.symbols_cache: dict[tuple, dict] = {}
+        self.generic_cache: dict[tuple, dict] = {}

     def _now(self) -> float:
         return time.time()

-    async def _cache_get(self, key):
+    def _cache_get(self, key):
         bucket = self.symbols_cache if isinstance(key, tuple) and key[:1] == ("spot",) else self.generic_cache
         item = bucket.get(key)
         if not item:
             return None
         if (self._now() - item["ts"]) > self.cache_ttl_seconds:
             try:
                 del bucket[key]
             except Exception:
                 pass
             return None
         return item["value"]

-    async def _cache_set(self, key, value):
+    def _cache_set(self, key, value):
         bucket = self.symbols_cache if isinstance(key, tuple) and key[:1] == ("spot",) else self.generic_cache
         bucket[key] = {"value": value, "ts": self._now()}

     async def get_spot_symbols(self, quote_coin: str = "USDT") -> list[str]:
         """
         Fetch tradable spot symbols filtered by quote currency. Safe caching.
         """
         q = (quote_coin or "USDT").upper()
         cache_key = ("spot", q)
         try:
-            cached = await self._cache_get(cache_key)
+            cached = self._cache_get(cache_key)
             if cached:
                 return cached
         except Exception:
             logger.debug("symbols cache get failed; continue without cache")
@@ -71,18 +86,54 @@ class UltraBybitClient:
         result = data.get("result") or {}
         items = result.get("list") or []
         out = []
         for it in items:
             if (it.get("quoteCoin") or "").upper() == q and (it.get("status") or "").lower() == "trading":
                 sym = it.get("symbol")
                 if sym:
                     out.append(sym)
         try:
-            await self._cache_set(cache_key, out)
+            self._cache_set(cache_key, out)
         except Exception:
             logger.debug("symbols cache set failed; continue without cache")
         return out
+
+    async def get_klines(self, symbol: str, interval: str, limit: int = 120):
+        """
+        Возвращает list[dict] с полями timestamp, open, high, low, close, volume.
+        Нормализует возможные форматы API/кэша, чтобы pd.DataFrame не падал.
+        """
+        cache_key = ("klines", symbol, interval, int(limit))
+        cached = None
+        try:
+            cached = self._cache_get(cache_key)
+        except Exception:
+            pass
+        if cached is not None:
+            data = cached
+        else:
+            url = f"{self.base_url}/v5/market/kline?category=spot&symbol={symbol}&interval={interval}&limit={limit}"
+            async with self._ensure_session() as s:
+                async with s.get(url, timeout=self.timeout) as resp:
+                    raw = await resp.json()
+            if (raw or {}).get("retCode") != 0:
+                raise BybitClientError("klines_fetch_failed", f"retCode={raw.get('retCode')}")
+            lst = (raw.get("result") or {}).get("list") or []
+            # Bybit v5 list: [ [start,open,high,low,close,volume,turnover], ... ]
+            data = [
+                {
+                    "timestamp": int(it[0]),
+                    "open": float(it[1]),
+                    "high": float(it[2]),
+                    "low": float(it[3]),
+                    "close": float(it[4]),
+                    "volume": float(it[5]),
+                }
+                for it in lst if isinstance(it, (list, tuple)) and len(it) >= 6
+            ]
+            try:
+                self._cache_set(cache_key, data)
+            except Exception:
+                pass
+        return data
diff --git a/app.py b/app.py
index 2222222..4444444 100644
--- a/app.py
+++ b/app.py
@@ -1,15 +1,20 @@
 import os
 import logging
 import json
-from datetime import datetime
+from datetime import datetime, timezone
 import asyncio
 from flask import Flask, jsonify, request, render_template
 from flask_caching import Cache
 from flask_socketio import SocketIO
 from typing import Any
-from backend.bybit_client import UltraBybitClient, BybitClientError
+from backend.bybit_client import UltraBybitClient, BybitClientError

 app = Flask(__name__)
 cache = Cache(app, config={"CACHE_TYPE": "SimpleCache", "CACHE_DEFAULT_TIMEOUT": 60})
@@ -26,6 +31,12 @@ try:
 except Exception:
     app.logger.warning("SocketIO fallback to 'threading'")
     socketio = SocketIO(app, async_mode="threading", cors_allowed_origins="*")

+def _utcnow_iso() -> str:
+    # без DeprecationWarning
+    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
+
+
 def json_error(status: int, code: str, detail: str = ""):
     return jsonify({"error": code, "detail": detail}), status

@@ -40,18 +51,20 @@ def prewarm():
         else:
             import asyncio
             asyncio.get_event_loop().create_task(_client.get_spot_symbols("USDT"))
     except Exception as e:
         app.logger.warning("Pre-warm skipped: %s", e)
     app.logger.info("Pre-warming completed successfully")

-@app.get("/api/symbols")
-async def get_symbols():
+@app.get("/api/symbols")
+async def get_symbols():
     app.logger.info("GET /api/symbols - IP: %s", request.remote_addr)
     quote_coin = (request.args.get("quote") or "USDT").upper()
     source = request.args.get("source", "bybit")
     try:
-        if source == "bybit":
-            symbols = await _client.get_spot_symbols(quote_coin)
-        else:
-            symbols = await get_available_symbols(quote_coin, source)
-        return jsonify({"symbols": symbols, "count": len(symbols)})
+        if source == "bybit":
+            symbols = await _client.get_spot_symbols(quote_coin)
+        else:
+            # если эта функция синхронная — просто вызов; если async — дождёмся
+            res = get_available_symbols(quote_coin, source)
+            symbols = await res if asyncio.iscoroutine(res) else res
+        return jsonify({"symbols": symbols, "count": len(symbols)}), 200
     except BybitClientError as e:
         app.logger.error("Symbols fetch error (client): %s", e, exc_info=False)
         return json_error(502, e.code, e.details)
     except Exception as e:
         app.logger.error("Symbols fetch error: %s", e, exc_info=True)
         return json_error(502, "symbols_fetch_failed", str(e))
@@ -59,30 +72,46 @@ async def get_symbols():

-@app.get("/api/market-data")
-def market_data():
+@app.get("/api/market-data")
+async def market_data():
     app.logger.info("GET /api/market-data - IP: %s", request.remote_addr)
     symbol = request.args.get("symbol", "BTCUSDT")
     timeframe = request.args.get("timeframe", "15")
     limit = int(request.args.get("limit", "200"))
     try:
-        payload = build_market_data_payload(symbol, timeframe, limit)
-        response_data = {
-            'symbol': symbol,
-            'timeframe': timeframe,
-            'limit': limit,
-            'timestamp': datetime.utcnow().isoformat() + 'Z',
-            **payload
-        }
+        payload = build_market_data_payload(symbol, timeframe, limit)
+        if asyncio.iscoroutine(payload):
+            payload = await payload
+        response_data = {
+            'symbol': symbol,
+            'timeframe': timeframe,
+            'limit': limit,
+            'timestamp': _utcnow_iso(),
+            **(payload or {})
+        }
         etag = generate_etag(response_data)
         # ETag обработка, если есть If-None-Match — оставляем как было
         return jsonify(response_data), 200
     except Exception as e:
         app.logger.error("Market data error: %s", e, exc_info=True)
         return json_error(502, "market_data_failed", str(e))

-@app.get("/api/historical-data/<symbol>")
-def historical_data(symbol: str):
+@app.get("/api/historical-data/<symbol>")
+async def historical_data(symbol: str):
     tf = request.args.get("timeframe", "15")
     limit = int(request.args.get("limit", "120"))
     try:
-        data = get_historical_klines(symbol, tf, limit)
+        res = get_historical_klines(symbol, tf, limit)
+        data = await res if asyncio.iscoroutine(res) else res
         return jsonify({"data": data}), 200
     except Exception as e:
         app.logger.exception("historical-data error")
         return json_error(502, "historical_data_failed", str(e))

-@app.get("/api/signals/<symbol>")
-def signals(symbol: str):
+@app.get("/api/signals/<symbol>")
+async def signals(symbol: str):
     timeframe = request.args.get("timeframe", "15")
     limit = int(request.args.get("limit", "6"))
     try:
-        items = get_signals(symbol, timeframe, limit)
+        res = get_signals(symbol, timeframe, limit)
+        items = await res if asyncio.iscoroutine(res) else res
         return jsonify({"signals": items}), 200
     except Exception as e:
         app.logger.exception("signals error")
         return json_error(502, "signals_failed", str(e))
