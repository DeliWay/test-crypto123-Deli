diff --git a/backend/bybit_client.py b/backend/bybit_client.py
index abcdef1..1234567 100644
--- a/backend/bybit_client.py
+++ b/backend/bybit_client.py
@@ -1,6 +1,7 @@
 """
 ULTRA-PERFORMANCE BYBIT CLIENT
 Асинхронный клиент с 15x улучшением производительности
+Встроенное кэширование с TTL для избежания AttributeError
 Самостоятельная реализация без внешних зависимостей
 """
 import os
@@ -17,6 +18,10 @@ from circuitbreaker import circuit
 from dataclasses import dataclass
 import hashlib

+class BybitClientError(Exception):
+    """Кастомное исключение для ошибок клиента Bybit"""
+    pass
+
 logger = logging.getLogger(__name__)

 # Конфигурация
@@ -40,6 +45,8 @@ class UltraBybitClient:
     def __new__(cls):
         if cls._instance is None:
             cls._instance = super().__new__(cls)
+            cls._instance.symbols_cache = {}
+            cls._instance.generic_cache = {}
         return cls._instance

     async def init(self):
@@ -68,7 +75,7 @@ class UltraBybitClient:
                 self._redis = await redis.from_url(
                     REDIS_URL,
                     decode_responses=True,
-                    max_connections=100,
+                    max_connections=10,
                     socket_timeout=1
                 )
                 await self._redis.ping()
@@ -77,7 +84,7 @@ class UltraBybitClient:
                 self._redis = None

         self.rate_limiter = UltraRateLimiter(10, 0.5)
-        self.symbols_cache = {}
+        self.cache_ttl_seconds = CACHE_TTL
         self.request_stats = []

     async def close(self):
@@ -94,6 +101,26 @@ class UltraBybitClient:
         self._ws_connections.clear()

     @lru_cache(maxsize=10000)
+    def _now(self):
+        """Текущее время для кэширования"""
+        return time.time()
+
+    def _cache_get(self, key):
+        """Получение данных из внутреннего кэша"""
+        if key in self.symbols_cache:
+            cached_data = self.symbols_cache[key]
+            if self._now() - cached_data['ts'] <= self.cache_ttl_seconds:
+                return cached_data['value']
+            else:
+                del self.symbols_cache[key]
+        return None
+
+    def _cache_set(self, key, value):
+        """Сохранение данных во внутренний кэш"""
+        self.symbols_cache[key] = {'value': value, 'ts': self._now()}
+        return True
+
+    @lru_cache(maxsize=10000)
     def _generate_cache_key(self, endpoint: str, **params) -> str:
         """Генерация ключа кэша"""
         param_str = '_'.join(f"{k}_{v}" for k, v in sorted(params.items()))
@@ -102,7 +129,7 @@ class UltraBybitClient:
     async def _cache_get(self, key: str) -> Optional[Any]:
         """Получение данных из кэша"""
         if not self._redis:
-            return self.symbols_cache.get(key)
+            return self._cache_get(key)

         try:
             data = await self._redis.get(key)
@@ -113,7 +140,7 @@ class UltraBybitClient:
     async def _cache_set(self, key: str, data: Any, ttl: int = CACHE_TTL):
         """Сохранение данных в кэш"""
         self.symbols_cache[key] = data
-        if self._redis:
+        if self._redis and not self._redis.closed:
             try:
                 await self._redis.setex(key, ttl, json.dumps(data))
             except Exception as e:
@@ -163,25 +190,33 @@ class UltraBybitClient:

     async def get_spot_symbols(self, quote_coin: str = 'USDT') -> List[str]:
         """Получение списка спот символов"""
-        cache_key = f"symbols:{quote_coin}"
-        cached = await self._cache_get(cache_key)
+        cache_key = ("spot", quote_coin.upper())
+        cached = self._cache_get(cache_key)
         if cached:
             return cached

-        data = await self._make_request('market/instruments-info', {'category': 'spot'})
-        if not data:
-            return await self._get_default_symbols()
+        try:
+            data = await self._make_request('market/instruments-info', {'category': 'spot'})
+            if not data:
+                raise BybitClientError("No data received from Bybit API")

-        symbols_list = data.get('result', {}).get('list', [])
-        symbols = [
-            symbol['symbol'] for symbol in symbols_list
-            if (symbol.get('quoteCoin') == quote_coin and
-                symbol.get('status') == 'Trading')
-        ]
+            symbols_list = data.get('result', {}).get('list', [])
+            if not symbols_list:
+                raise BybitClientError("Empty symbols list from Bybit")

-        symbols = sorted(symbols)
-        await self._cache_set(cache_key, symbols)
-        return symbols
+            symbols = [
+                symbol['symbol'] for symbol in symbols_list
+                if (symbol.get('quoteCoin') == quote_coin and
+                    symbol.get('status') == 'Trading')
+            ]
+
+            symbols = sorted(symbols)
+            self._cache_set(cache_key, symbols)
+            return symbols
+
+        except Exception as e:
+            logger.error(f"Error fetching symbols from Bybit: {e}")
+            return await self._get_default_symbols()

     async def _get_default_symbols(self) -> List[str]:
         """Резервный список символов"""
diff --git a/app.py b/app.py
index abcdef1..1234567 100644
--- a/app.py
+++ b/app.py
@@ -1,5 +1,6 @@
 import asyncio
 import logging
+import os
 import json
 import time
 import threading
@@ -60,12 +61,19 @@ except Exception as e:
     cache = Cache(app, config={'CACHE_TYPE': 'SimpleCache'})

 # WebSocket
+async_mode = os.getenv('SOCKETIO_ASYNC_MODE', 'threading')
 try:
-    socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet',
-                        logger=False, engineio_logger=False)
+    socketio = SocketIO(
+        app,
+        cors_allowed_origins="*",
+        async_mode=async_mode,
+        logger=False,
+        engineio_logger=False
+    )
 except Exception as e:
-    socketio = None
-    logger.warning(f"SocketIO initialization failed: {e}")
+    logger.warning(f"SocketIO initialization failed with {async_mode}: {e}, falling back to threading")
+    socketio = SocketIO(app, async_mode='threading', cors_allowed_origins="*",
+                       logger=False, engineio_logger=False)

 # Инициализация клиентов

@@ -110,6 +118,12 @@ def cleanup_memory_cache() -> None:
         logger.info(f"Memory cache cleaned: {len(keys_to_delete)} entries removed")


+def json_error(status: int, code: str, detail: str) -> Response:
+    """Универсальный хелпер для JSON ошибок"""
+    response = jsonify({'error': code, 'detail': detail})
+    response.status_code = status
+    return response
+
 def generate_etag(data: Any) -> str:
     """Генерация ETag для кэширования"""
     if isinstance(data, (dict, list)):
@@ -233,7 +247,6 @@ def index() -> str:


 @app.route('/api/market-data')
-@cache.cached(timeout=60, query_string=True)
 @async_handler
 async def market_data() -> Response:
     """Комплексный эндпоинт рыночных данных"""
@@ -308,7 +321,6 @@ async def market_data() -> Response:


 @app.route('/api/technical-analysis/<symbol>')
-@cache.cached(timeout=30, query_string=True)
 @async_handler
 async def technical_analysis(symbol: str) -> Response:
     """Расширенный технический анализ"""
@@ -379,7 +391,6 @@ async def ml_analysis(symbol: str) -> Response:


 @app.route('/api/symbols')
-@cache.cached(timeout=3600)
 @async_handler
 async def get_symbols() -> Response:
     """Получение списка символов"""
@@ -388,15 +399,19 @@ async def get_symbols() -> Response:
         source = request.args.get('source', 'bybit')

         symbols = await get_available_symbols(quote_coin, source)
+        if not symbols:
+            return json_error(502, 'symbols_fetch_failed', 'No symbols available from exchange')

         return jsonify({
             'symbols': symbols,
             'count': len(symbols),
             'quote_coin': quote_coin,
             'source': source,
-            'timestamp': datetime.utcnow().isoformat() + 'Z'
+            'timestamp': datetime.utcnow().isoformat() + 'Z',
+            'cached': False
         })

     except Exception as e:
         logger.error(f"Symbols fetch error: {e}", exc_info=True)
-        return jsonify({'error': str(e)}), 500
+        return json_error(502, 'symbols_fetch_failed',
+                         f'Failed to fetch symbols: {str(e)}')

@@ -405,7 +420,6 @@ async def get_symbols() -> Response:


 @app.route('/api/orderbook/<symbol>')
-@cache.cached(timeout=5, query_string=True)
 @async_handler
 async def get_orderbook_endpoint(symbol: str) -> Response:
     """Стакан заявок"""
@@ -427,7 +441,6 @@ async def get_orderbook_endpoint(symbol: str) -> Response:


 @app.route('/api/historical-data/<symbol>')
-@cache.cached(timeout=300, query_string=True)
 @async_handler
 async def historical_data(symbol: str) -> Response:
     """Исторические данные"""
@@ -477,7 +490,6 @@ async def historical_data(symbol: str) -> Response:


 @app.route('/api/indicators/<symbol>')
-@cache.cached(timeout=60, query_string=True)
 @async_handler
 async def get_indicators(symbol: str) -> Response:
     """Получение технических индикаторов"""
@@ -506,7 +518,6 @@ async def get_indicators(symbol: str) -> Response:


 @app.route('/api/signals/<symbol>')
-@cache.cached(timeout=30, query_string=True)
 @async_handler
 async def get_signals(symbol: str) -> Response:
     """Получение торговых сигналов"""
@@ -659,7 +670,6 @@ def health_check() -> Response:


 @app.route('/api/performance')
-@cache.cached(timeout=60)
 def performance_metrics() -> Response:
     """Метрики производительности"""
     metrics = {
@@ -682,7 +692,6 @@ def performance_metrics() -> Response:


 @app.route('/api/tradingview/config')
-@cache.cached(timeout=3600)
 @async_handler
 async def tradingview_config() -> Response:
     """Конфигурация TradingView"""
@@ -820,18 +829,21 @@ def initialize_app() -> None:
     def pre_warm_background():
         async def async_pre_warm():
             try:
-                logger.info("Pre-warming caches and services...")
+                logger.info("Starting background pre-warming...")

                 # Предзагрузка популярных символов
                 popular_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT']

                 for symbol in popular_symbols:
                     try:
-                        await get_market_data(symbol, '15', 100)
+                        data = await get_market_data(symbol, '15', 100)
+                        if data is not None:
+                            logger.debug(f"Pre-warmed data for {symbol}")
+                        else:
+                            logger.warning(f"Pre-warm failed for {symbol}: No data")
                         await asyncio.sleep(0.1)  # Rate limiting
                     except Exception as e:
-                        logger.warning(f"Pre-warm failed for {symbol}: {e}")
-
+                        logger.warning(f"Pre-warm failed for {symbol}: {str(e)}")
                 logger.info("Pre-warming completed successfully")

             except Exception as e: