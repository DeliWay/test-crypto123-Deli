*** a/backend/bybit_client.py
--- b/backend/bybit_client.py
@@
-    async def get_klines(self, symbol: str, interval: str, limit: int = 200):
-        cached = self._cache_get(f"klines:{symbol}:{interval}:{limit}")
-        if cached:
-            return pd.DataFrame(cached)
-        data = await self._http_fetch_klines(symbol, interval, limit)
-        await self._cache_set(f"klines:{symbol}:{interval}:{limit}", data, ttl=15)
-        return pd.DataFrame(data)
+    async def get_klines(self, symbol: str, interval: str, limit: int = 200):
+        """
+        Возвращает pandas.DataFrame со свечами.
+        Кэш читается/пишется асинхронно. Данные проходят через безопасный нормализатор.
+        """
+        key = f"klines:{symbol}:{interval}:{limit}"
+        cached = await self._cache_get(key)
+        if cached:
+            df = _to_dataframe_safe(cached)
+            if df is not None:
+                return df
+        data = await self._http_fetch_klines(symbol, interval, limit)
+        await self._cache_set(key, data, ttl=15)
+        df = _to_dataframe_safe(data)
+        if df is None:
+            import pandas as pd
+            return pd.DataFrame(columns=["open_time","open","high","low","close","volume","close_time"])
+        return df
@@
-    async def get_symbols(self):
-        cached = self._cache_get("symbols")
-        if cached:
-            return cached
-        data = await self._http_fetch_symbols()
-        await self._cache_set("symbols", data, ttl=300)
-        return data
+    async def get_symbols(self):
+        """
+        Возвращает список тикеров (list[str]) с нормализацией формата.
+        """
+        cached = await self._cache_get("symbols")
+        if cached:
+            items = _extract_symbols_list(cached)
+            if items:
+                return items
+        data = await self._http_fetch_symbols()
+        await self._cache_set("symbols", data, ttl=300)
+        items = _extract_symbols_list(data)
+        return items or []
+
+def _extract_symbols_list(raw) -> list[str] | None:
+    if raw is None:
+        return None
+    if isinstance(raw, dict):
+        for k in ("list", "result", "data", "symbols"):
+            if k in raw and isinstance(raw[k], (list, tuple)):
+                raw = raw[k]
+                break
+    if isinstance(raw, (list, tuple)):
+        out = []
+        for item in raw:
+            if isinstance(item, str):
+                out.append(item)
+            elif isinstance(item, dict):
+                sym = item.get("symbol") or item.get("name") or item.get("ticker")
+                if sym:
+                    out.append(sym)
+        return out
+    return None
+
+def _to_dataframe_safe(raw):
+    """
+    Поддерживаем:
+      - list[dict]
+      - list[list] с маппингом колонок
+      - dict с 'list'/'result'/'data'
+    """
+    import pandas as pd
+    import numpy as np
+    if raw is None:
+        return None
+    if isinstance(raw, dict):
+        for key in ("list", "result", "data"):
+            if key in raw and isinstance(raw[key], (list, tuple)):
+                raw = raw[key]
+                break
+    if isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], dict):
+        df = pd.DataFrame.from_records(raw)
+    elif isinstance(raw, (list, tuple)) and raw and isinstance(raw[0], (list, tuple)):
+        cols = ["open_time","open","high","low","close","volume","close_time"]
+        df = pd.DataFrame.from_records(raw, columns=cols[:len(raw[0])])
+    elif raw == []:
+        df = pd.DataFrame(columns=["open_time","open","high","low","close","volume","close_time"])
+    else:
+        return None
+    for num_col in ("open","high","low","close","volume"):
+        if num_col in df.columns:
+            df[num_col] = pd.to_numeric(df[num_col], errors="coerce")
+    for tcol in ("open_time","close_time"):
+        if tcol in df.columns:
+            # допускаем ms/iso — coerce проставит NaT, если неподходит
+            try:
+                df[tcol] = pd.to_datetime(df[tcol], unit="ms", errors="coerce")
+            except Exception:
+                df[tcol] = pd.to_datetime(df[tcol], errors="coerce", utc=True)
+    return df
*** a/app.py
--- b/app.py
@@
-from datetime import datetime
+from datetime import datetime, timezone
+import asyncio
+import json
@@
-def generate_etag(data) -> str:
-    import hashlib, json
-    content = json.dumps(data, sort_keys=True)
+def generate_etag(data) -> str:
+    import hashlib, json
+    # default=str — защита от нестандартных типов (Timestamp/Decimal)
+    content = json.dumps(data, sort_keys=True, default=str)
     return hashlib.sha256(content.encode("utf-8")).hexdigest()
@@
-@app.route("/api/market-data")
-def market_data():
+@app.route("/api/market-data")
+async def market_data():
     app.logger.info("GET /api/market-data - IP: %s", request.remote_addr)
     symbol = request.args.get("symbol", "BTCUSDT")
     timeframe = request.args.get("timeframe", "15")
     limit = int(request.args.get("limit", 200))
     try:
-        candles = bybit_client.get_klines(symbol, timeframe, limit)
+        # КРИТИЧНО: ждём асинхронный результат
+        candles_df = await bybit_client.get_klines(symbol, timeframe, limit)
         response_data = {
             'symbol': symbol,
             'timeframe': timeframe,
             'limit': limit,
-            'timestamp': datetime.utcnow().isoformat() + 'Z',
-            'candles': json.loads(candles.to_json(orient="records"))
+            'timestamp': datetime.now(timezone.utc).isoformat(),
+            'candles': json.loads(candles_df.to_json(orient="records"))
         }
         etag = generate_etag(response_data)
         return jsonify(response_data), 200, {"ETag": etag}
     except Exception as e:
         app.logger.error(f"Market data error: {e}", exc_info=True)
         return jsonify({
             'error': 'market_data_failed',
             'detail': str(e),
-            'timestamp': datetime.utcnow().isoformat() + 'Z'
+            'timestamp': datetime.now(timezone.utc).isoformat()
         }), 500
@@
-@app.route("/api/symbols")
-def get_symbols():
+@app.route("/api/symbols")
+async def get_symbols():
     app.logger.info("GET /api/symbols - IP: %s", request.remote_addr)
     try:
-        symbols = bybit_client.get_symbols()
-        return jsonify({
-            'count': len(symbols),
-            'items': symbols,
-            'timestamp': datetime.utcnow().isoformat() + 'Z'
-        })
+        symbols = await bybit_client.get_symbols()
+        if isinstance(symbols, dict):
+            for k in ("list","result","data","symbols"):
+                if k in symbols and isinstance(symbols[k], (list, tuple)):
+                    symbols = symbols[k]
+                    break
+        symbols = [s if isinstance(s, str) else (s.get("symbol") if isinstance(s, dict) else None) for s in symbols]
+        symbols = [s for s in symbols if s]
+        return jsonify({
+            "count": len(symbols),
+            "items": symbols,
+            "timestamp": datetime.now(timezone.utc).isoformat()
+        })
     except Exception as e:
         app.logger.error(f"Symbols fetch error: {e}", exc_info=True)
-        return jsonify({'error': 'symbols_failed', 'detail': str(e)}), 502
+        return jsonify({"error": "symbols_failed", "detail": str(e)}), 502
@@
-@app.route("/api/signals/<symbol>")
-async def get_signals(symbol: str):
+@app.route("/api/signals/<symbol>")
+async def get_signals(symbol: str):
     timeframe = request.args.get("timeframe", "15")
     limit = int(request.args.get("limit", 200))
     try:
         # здесь должен приходить уже DataFrame
         market_df = await get_market_data(symbol, timeframe, limit)
         signals = await compute_signals_async(market_df)
         return jsonify({
             "symbol": symbol,
             "timeframe": timeframe,
             "limit": limit,
-            "timestamp": datetime.utcnow().isoformat() + "Z",
+            "timestamp": datetime.now(timezone.utc).isoformat(),
             "signals": signals
         })
     except Exception as e:
         app.logger.error(f"Signals error for {symbol}: {e}", exc_info=True)
         return jsonify({
             "error": "signals_failed",
             "detail": str(e),
-            "timestamp": datetime.utcnow().isoformat() + "Z"
+            "timestamp": datetime.now(timezone.utc).isoformat()
         }), 500
@@
-# === legacy sync prewarm ===
-def _background_prewarm(symbols: list[str], timeframe: str = "15", limit: int = 200):
-    logger.info("Starting background pre-warming...")
-    for symbol in symbols:
-        try:
-            # БЫЛО ПЛОХО: прямой вызов корутины без await
-            bybit_client._cache_get(f"klines:{symbol}:{timeframe}:{limit}")
-        except Exception as e:
-            logger.warning(f"Pre-warm failed for {symbol}: {str(e)}")
-    logger.info("Pre-warming completed successfully")
+async def _async_prewarm(symbols: list[str], timeframe: str = "15", limit: int = 200):
+    logger.info("Starting background pre-warming...")
+    async def warm_one(sym: str):
+        try:
+            await bybit_client.get_klines(sym, timeframe, limit)
+        except Exception as e:
+            logger.warning(f"Pre-warm failed for {sym}: {str(e)}")
+    await asyncio.gather(*(warm_one(s) for s in symbols), return_exceptions=True)
+    logger.info("Pre-warming completed successfully")
@@
 if __name__ == "__main__":
     logger.info("Starting application initialization...")
     # ... инициализация
     logger.info("Application initialization complete")
-    logger.info("Starting background pre-warming...")
-    try:
-        _background_prewarm(["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT"], timeframe="15", limit=200)
-    except Exception:
-        pass
-    logger.info("Pre-warming completed successfully")
+    try:
+        asyncio.run(_async_prewarm(["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT"], timeframe="15", limit=200))
+    except RuntimeError:
+        import threading
+        threading.Thread(target=lambda: asyncio.run(_async_prewarm(
+            ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT"], timeframe="15", limit=200
+        )), daemon=True).start()
     app.run(host="0.0.0.0", port=5000, debug=True)
@@
-# где-то ниже по коду:
-# return jsonify({'patterns': PATTERNS_INDEX, 'timestamp': datetime.utcnow().isoformat() + 'Z'}), 404
+# если есть ответ /patterns — убираем депрекейт
+# пример:
+# return jsonify({'patterns': PATTERNS_INDEX, 'timestamp': datetime.now(timezone.utc).isoformat()}), 404
